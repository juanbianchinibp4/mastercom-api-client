/*
 * MasterCom
 * MasterCom
 *
 * The version of the OpenAPI document: v6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package fiserv.mastercom_api_client.model;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import fiserv.mastercom_api_client.JSON;

import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * ChargebackDetails
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-07T19:57:39.604201-03:00[America/Buenos_Aires]")
public class ChargebackDetails {
  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_CREATE_DATE = "createDate";
  @SerializedName(SERIALIZED_NAME_CREATE_DATE)
  private String createDate;

  public static final String SERIALIZED_NAME_DOCUMENT_INDICATOR = "documentIndicator";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_INDICATOR)
  private String documentIndicator;

  public static final String SERIALIZED_NAME_MESSAGE_TEXT = "messageText";
  @SerializedName(SERIALIZED_NAME_MESSAGE_TEXT)
  private String messageText;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private String amount;

  public static final String SERIALIZED_NAME_REASON_CODE = "reasonCode";
  @SerializedName(SERIALIZED_NAME_REASON_CODE)
  private String reasonCode;

  public static final String SERIALIZED_NAME_IS_PARTIAL_CHARGEBACK = "isPartialChargeback";
  @SerializedName(SERIALIZED_NAME_IS_PARTIAL_CHARGEBACK)
  private Boolean isPartialChargeback;

  /**
   * Provide the chargeback type.  The following values are valid - CHARGEBACK, SECOND_PRESENTMENT
   */
  @JsonAdapter(ChargebackTypeEnum.Adapter.class)
  public enum ChargebackTypeEnum {
    CHARGEBACK("CHARGEBACK"),
    
    SECOND_PRESENTMENT("SECOND_PRESENTMENT");

    private String value;

    ChargebackTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ChargebackTypeEnum fromValue(String value) {
      for (ChargebackTypeEnum b : ChargebackTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ChargebackTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ChargebackTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ChargebackTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ChargebackTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CHARGEBACK_TYPE = "chargebackType";
  @SerializedName(SERIALIZED_NAME_CHARGEBACK_TYPE)
  private ChargebackTypeEnum chargebackType;

  public static final String SERIALIZED_NAME_CHARGEBACK_ID = "chargebackId";
  @SerializedName(SERIALIZED_NAME_CHARGEBACK_ID)
  private String chargebackId;

  public static final String SERIALIZED_NAME_CLAIM_ID = "claimId";
  @SerializedName(SERIALIZED_NAME_CLAIM_ID)
  private String claimId;

  public static final String SERIALIZED_NAME_REVERSED = "reversed";
  @SerializedName(SERIALIZED_NAME_REVERSED)
  private Boolean reversed;

  public static final String SERIALIZED_NAME_REVERSAL = "reversal";
  @SerializedName(SERIALIZED_NAME_REVERSAL)
  private Boolean reversal;

  public static final String SERIALIZED_NAME_CHARGEBACK_REF_NUM = "chargebackRefNum";
  @SerializedName(SERIALIZED_NAME_CHARGEBACK_REF_NUM)
  private String chargebackRefNum;

  public static final String SERIALIZED_NAME_DOCUMENT_STATUS = "documentStatus";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_STATUS)
  private String documentStatus;

  public static final String SERIALIZED_NAME_RECONCILIATION_AMOUNT = "reconciliationAmount";
  @SerializedName(SERIALIZED_NAME_RECONCILIATION_AMOUNT)
  private String reconciliationAmount;

  public static final String SERIALIZED_NAME_RECONCILIATION_CURRENCY = "reconciliationCurrency";
  @SerializedName(SERIALIZED_NAME_RECONCILIATION_CURRENCY)
  private String reconciliationCurrency;

  public static final String SERIALIZED_NAME_REJECT_REASON = "rejectReason";
  @SerializedName(SERIALIZED_NAME_REJECT_REASON)
  private String rejectReason;

  public static final String SERIALIZED_NAME_EDIT_EXCLUSION_CODE = "editExclusionCode";
  @SerializedName(SERIALIZED_NAME_EDIT_EXCLUSION_CODE)
  private String editExclusionCode;

  public static final String SERIALIZED_NAME_REFUND_NOT_RECEIVED_INDICATOR = "refundNotReceivedIndicator";
  @SerializedName(SERIALIZED_NAME_REFUND_NOT_RECEIVED_INDICATOR)
  private String refundNotReceivedIndicator;

  public static final String SERIALIZED_NAME_CREDIT_VOUCHER_STATUS = "creditVoucherStatus";
  @SerializedName(SERIALIZED_NAME_CREDIT_VOUCHER_STATUS)
  private String creditVoucherStatus;

  public static final String SERIALIZED_NAME_CURRENCY_CONVERSION_ASSESSMENT_C_C_A_INCLUDED = "currencyConversionAssessmentCCAIncluded";
  @SerializedName(SERIALIZED_NAME_CURRENCY_CONVERSION_ASSESSMENT_C_C_A_INCLUDED)
  private String currencyConversionAssessmentCCAIncluded;

  public static final String SERIALIZED_NAME_CURRENCY_CONVERSION_ASSESSMENT_C_C_A_AMOUNT = "currencyConversionAssessmentCCAAmount";
  @SerializedName(SERIALIZED_NAME_CURRENCY_CONVERSION_ASSESSMENT_C_C_A_AMOUNT)
  private String currencyConversionAssessmentCCAAmount;

  public static final String SERIALIZED_NAME_JAPAN_COMMON_MERCHANT_CODE = "japanCommonMerchantCode";
  @SerializedName(SERIALIZED_NAME_JAPAN_COMMON_MERCHANT_CODE)
  private String japanCommonMerchantCode;

  public static final String SERIALIZED_NAME_INSTALLMENT_DATA = "installmentData";
  @SerializedName(SERIALIZED_NAME_INSTALLMENT_DATA)
  private String installmentData;

  public static final String SERIALIZED_NAME_FLEX_CODE = "flexCode";
  @SerializedName(SERIALIZED_NAME_FLEX_CODE)
  private String flexCode;

  public ChargebackDetails() {
  }

  public ChargebackDetails currency(String currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * The chargeback currency.  The data should be standard currency alpha code
   * @return currency
  **/
  @javax.annotation.Nullable
  public String getCurrency() {
    return currency;
  }


  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public ChargebackDetails createDate(String createDate) {
    
    this.createDate = createDate;
    return this;
  }

   /**
   * This is the date of the chargeback creation
   * @return createDate
  **/
  @javax.annotation.Nullable
  public String getCreateDate() {
    return createDate;
  }


  public void setCreateDate(String createDate) {
    this.createDate = createDate;
  }


  public ChargebackDetails documentIndicator(String documentIndicator) {
    
    this.documentIndicator = documentIndicator;
    return this;
  }

   /**
   * Document Indicator
   * @return documentIndicator
  **/
  @javax.annotation.Nullable
  public String getDocumentIndicator() {
    return documentIndicator;
  }


  public void setDocumentIndicator(String documentIndicator) {
    this.documentIndicator = documentIndicator;
  }


  public ChargebackDetails messageText(String messageText) {
    
    this.messageText = messageText;
    return this;
  }

   /**
   * Member message text to be used for the chargeback
   * @return messageText
  **/
  @javax.annotation.Nullable
  public String getMessageText() {
    return messageText;
  }


  public void setMessageText(String messageText) {
    this.messageText = messageText;
  }


  public ChargebackDetails amount(String amount) {
    
    this.amount = amount;
    return this;
  }

   /**
   * Chargeback Amount
   * @return amount
  **/
  @javax.annotation.Nullable
  public String getAmount() {
    return amount;
  }


  public void setAmount(String amount) {
    this.amount = amount;
  }


  public ChargebackDetails reasonCode(String reasonCode) {
    
    this.reasonCode = reasonCode;
    return this;
  }

   /**
   * Chargeback Reason Code
   * @return reasonCode
  **/
  @javax.annotation.Nullable
  public String getReasonCode() {
    return reasonCode;
  }


  public void setReasonCode(String reasonCode) {
    this.reasonCode = reasonCode;
  }


  public ChargebackDetails isPartialChargeback(Boolean isPartialChargeback) {
    
    this.isPartialChargeback = isPartialChargeback;
    return this;
  }

   /**
   * Indicates a partial chargeback
   * @return isPartialChargeback
  **/
  @javax.annotation.Nullable
  public Boolean getIsPartialChargeback() {
    return isPartialChargeback;
  }


  public void setIsPartialChargeback(Boolean isPartialChargeback) {
    this.isPartialChargeback = isPartialChargeback;
  }


  public ChargebackDetails chargebackType(ChargebackTypeEnum chargebackType) {
    
    this.chargebackType = chargebackType;
    return this;
  }

   /**
   * Provide the chargeback type.  The following values are valid - CHARGEBACK, SECOND_PRESENTMENT
   * @return chargebackType
  **/
  @javax.annotation.Nullable
  public ChargebackTypeEnum getChargebackType() {
    return chargebackType;
  }


  public void setChargebackType(ChargebackTypeEnum chargebackType) {
    this.chargebackType = chargebackType;
  }


  public ChargebackDetails chargebackId(String chargebackId) {
    
    this.chargebackId = chargebackId;
    return this;
  }

   /**
   * Identifier assigned to the Chargeback
   * @return chargebackId
  **/
  @javax.annotation.Nullable
  public String getChargebackId() {
    return chargebackId;
  }


  public void setChargebackId(String chargebackId) {
    this.chargebackId = chargebackId;
  }


  public ChargebackDetails claimId(String claimId) {
    
    this.claimId = claimId;
    return this;
  }

   /**
   * Claim identifier
   * @return claimId
  **/
  @javax.annotation.Nullable
  public String getClaimId() {
    return claimId;
  }


  public void setClaimId(String claimId) {
    this.claimId = claimId;
  }


  public ChargebackDetails reversed(Boolean reversed) {
    
    this.reversed = reversed;
    return this;
  }

   /**
   * Indicates this chargeback has been reversed
   * @return reversed
  **/
  @javax.annotation.Nullable
  public Boolean getReversed() {
    return reversed;
  }


  public void setReversed(Boolean reversed) {
    this.reversed = reversed;
  }


  public ChargebackDetails reversal(Boolean reversal) {
    
    this.reversal = reversal;
    return this;
  }

   /**
   * Indicates this chargeback is a reversal chargeback
   * @return reversal
  **/
  @javax.annotation.Nullable
  public Boolean getReversal() {
    return reversal;
  }


  public void setReversal(Boolean reversal) {
    this.reversal = reversal;
  }


  public ChargebackDetails chargebackRefNum(String chargebackRefNum) {
    
    this.chargebackRefNum = chargebackRefNum;
    return this;
  }

   /**
   * Contains card issuer reference data for a specific cardholder transaction. This number must be unique within BIN. It is used to track the chargeback throughout its life cycle
   * @return chargebackRefNum
  **/
  @javax.annotation.Nullable
  public String getChargebackRefNum() {
    return chargebackRefNum;
  }


  public void setChargebackRefNum(String chargebackRefNum) {
    this.chargebackRefNum = chargebackRefNum;
  }


  public ChargebackDetails documentStatus(String documentStatus) {
    
    this.documentStatus = documentStatus;
    return this;
  }

   /**
   * The document status on chargebacks is helpful for customers to identify the chargebacks that need documents to be uploaded within the stipulated 8 days limit for uploading documentation after chargeback creation.
   * @return documentStatus
  **/
  @javax.annotation.Nullable
  public String getDocumentStatus() {
    return documentStatus;
  }


  public void setDocumentStatus(String documentStatus) {
    this.documentStatus = documentStatus;
  }


  public ChargebackDetails reconciliationAmount(String reconciliationAmount) {
    
    this.reconciliationAmount = reconciliationAmount;
    return this;
  }

   /**
   * Reconciliation amount of the chargeback type. Amount will only be retrieved by the receiver side of the dispute cycle.
   * @return reconciliationAmount
  **/
  @javax.annotation.Nullable
  public String getReconciliationAmount() {
    return reconciliationAmount;
  }


  public void setReconciliationAmount(String reconciliationAmount) {
    this.reconciliationAmount = reconciliationAmount;
  }


  public ChargebackDetails reconciliationCurrency(String reconciliationCurrency) {
    
    this.reconciliationCurrency = reconciliationCurrency;
    return this;
  }

   /**
   * Reconciliation currency of the chargeback type. Currency will only be retrieved by the receiver side of the dispute cycle.
   * @return reconciliationCurrency
  **/
  @javax.annotation.Nullable
  public String getReconciliationCurrency() {
    return reconciliationCurrency;
  }


  public void setReconciliationCurrency(String reconciliationCurrency) {
    this.reconciliationCurrency = reconciliationCurrency;
  }


  public ChargebackDetails rejectReason(String rejectReason) {
    
    this.rejectReason = rejectReason;
    return this;
  }

   /**
   * Chargeback reject reason.  Bridged chargeback reject reason - Possible values:   Code1&#x3D;2802(00):D0025/000;DE072&#x3D;D0025\\\\\\\\0000\\\\\\\\\\\\\\\\ - Ineligible chargeback reject reason codes &#39;FNS COUNTER EXCEEDED&#39;   Code1&#x3D;2801(00):D0025/000;DE072&#x3D;D0025\\\\\\\\0000\\\\\\\\\\\\\\\\ - Ineligible chargeback reject reason codes &#39;FNS DATE EXCEEDED&#39;   Code1&#x3D;2570(00):D0025/000;DE072&#x3D;D0025\\\\\\\\0000\\\\\\\\\\\\\\\\ - Chargeback not allowed beyond 120 days of transaction date   Code1&#x3D;5050(00):D0025/000;DE072&#x3D;D0025\\\\\\\\0000\\\\\\\\\\\\\\\\ - New amount and Org amount can&#39;t be equal   Code1&#x3D;5051(00):D0025/000;DE072&#x3D;D0025\\\\\\\\0000\\\\\\\\\\\\\\\\ - Other errors               
   * @return rejectReason
  **/
  @javax.annotation.Nullable
  public String getRejectReason() {
    return rejectReason;
  }


  public void setRejectReason(String rejectReason) {
    this.rejectReason = rejectReason;
  }


  public ChargebackDetails editExclusionCode(String editExclusionCode) {
    
    this.editExclusionCode = editExclusionCode;
    return this;
  }

   /**
   * Edit exclusion code to bypass clearing system edits. Valid Values - Y ,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,BA,BB,BC,BD,BE,BF,BG,BH,BI,BJ,BK,BL,BM,BN,BO,BP,BQ,BR,BS,BT,BU,BV,BW,BX,BY,BZ,SPACES.
   * @return editExclusionCode
  **/
  @javax.annotation.Nullable
  public String getEditExclusionCode() {
    return editExclusionCode;
  }


  public void setEditExclusionCode(String editExclusionCode) {
    this.editExclusionCode = editExclusionCode;
  }


  public ChargebackDetails refundNotReceivedIndicator(String refundNotReceivedIndicator) {
    
    this.refundNotReceivedIndicator = refundNotReceivedIndicator;
    return this;
  }

   /**
   * Cardholder/Issuer did not receive refund when a first chargeback was rejected by Collaboration with reason code 5000 indicating refund provided. 20 days after rejection of CB through collaboration. This field is only applicable if chargebackType is CHARGEBACK. Valid values are: true, false.
   * @return refundNotReceivedIndicator
  **/
  @javax.annotation.Nullable
  public String getRefundNotReceivedIndicator() {
    return refundNotReceivedIndicator;
  }


  public void setRefundNotReceivedIndicator(String refundNotReceivedIndicator) {
    this.refundNotReceivedIndicator = refundNotReceivedIndicator;
  }


  public ChargebackDetails creditVoucherStatus(String creditVoucherStatus) {
    
    this.creditVoucherStatus = creditVoucherStatus;
    return this;
  }

   /**
   * The actual status of the credit voucher
   * @return creditVoucherStatus
  **/
  @javax.annotation.Nullable
  public String getCreditVoucherStatus() {
    return creditVoucherStatus;
  }


  public void setCreditVoucherStatus(String creditVoucherStatus) {
    this.creditVoucherStatus = creditVoucherStatus;
  }


  public ChargebackDetails currencyConversionAssessmentCCAIncluded(String currencyConversionAssessmentCCAIncluded) {
    
    this.currencyConversionAssessmentCCAIncluded = currencyConversionAssessmentCCAIncluded;
    return this;
  }

   /**
   * Currency Conversion Assessment amount applied for full first chargeback, to indicate, if Currency Conversion Assessment was included or not for qualified transactions.
   * @return currencyConversionAssessmentCCAIncluded
  **/
  @javax.annotation.Nullable
  public String getCurrencyConversionAssessmentCCAIncluded() {
    return currencyConversionAssessmentCCAIncluded;
  }


  public void setCurrencyConversionAssessmentCCAIncluded(String currencyConversionAssessmentCCAIncluded) {
    this.currencyConversionAssessmentCCAIncluded = currencyConversionAssessmentCCAIncluded;
  }


  public ChargebackDetails currencyConversionAssessmentCCAAmount(String currencyConversionAssessmentCCAAmount) {
    
    this.currencyConversionAssessmentCCAAmount = currencyConversionAssessmentCCAAmount;
    return this;
  }

   /**
   * Currency Conversion Assessment amount Fee associated with full first chargeback.
   * @return currencyConversionAssessmentCCAAmount
  **/
  @javax.annotation.Nullable
  public String getCurrencyConversionAssessmentCCAAmount() {
    return currencyConversionAssessmentCCAAmount;
  }


  public void setCurrencyConversionAssessmentCCAAmount(String currencyConversionAssessmentCCAAmount) {
    this.currencyConversionAssessmentCCAAmount = currencyConversionAssessmentCCAAmount;
  }


  public ChargebackDetails japanCommonMerchantCode(String japanCommonMerchantCode) {
    
    this.japanCommonMerchantCode = japanCommonMerchantCode;
    return this;
  }

   /**
   * Identifies the merchant&#39;s category in Japan referred to as the Common Merchant Category Code (CMC). Mastercard uses this value to identify a link to a corresponding Mastercard Assigned ID.
   * @return japanCommonMerchantCode
  **/
  @javax.annotation.Nullable
  public String getJapanCommonMerchantCode() {
    return japanCommonMerchantCode;
  }


  public void setJapanCommonMerchantCode(String japanCommonMerchantCode) {
    this.japanCommonMerchantCode = japanCommonMerchantCode;
  }


  public ChargebackDetails installmentData(String installmentData) {
    
    this.installmentData = installmentData;
    return this;
  }

   /**
   * Provides information about the installment payment option selected by the cardholder at the point of interaction.
   * @return installmentData
  **/
  @javax.annotation.Nullable
  public String getInstallmentData() {
    return installmentData;
  }


  public void setInstallmentData(String installmentData) {
    this.installmentData = installmentData;
  }


  public ChargebackDetails flexCode(String flexCode) {
    
    this.flexCode = flexCode;
    return this;
  }

   /**
   * Specific to Brazil Flex Card transactions to communicate the product code used for clearing.
   * @return flexCode
  **/
  @javax.annotation.Nullable
  public String getFlexCode() {
    return flexCode;
  }


  public void setFlexCode(String flexCode) {
    this.flexCode = flexCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChargebackDetails chargebackDetails = (ChargebackDetails) o;
    return Objects.equals(this.currency, chargebackDetails.currency) &&
        Objects.equals(this.createDate, chargebackDetails.createDate) &&
        Objects.equals(this.documentIndicator, chargebackDetails.documentIndicator) &&
        Objects.equals(this.messageText, chargebackDetails.messageText) &&
        Objects.equals(this.amount, chargebackDetails.amount) &&
        Objects.equals(this.reasonCode, chargebackDetails.reasonCode) &&
        Objects.equals(this.isPartialChargeback, chargebackDetails.isPartialChargeback) &&
        Objects.equals(this.chargebackType, chargebackDetails.chargebackType) &&
        Objects.equals(this.chargebackId, chargebackDetails.chargebackId) &&
        Objects.equals(this.claimId, chargebackDetails.claimId) &&
        Objects.equals(this.reversed, chargebackDetails.reversed) &&
        Objects.equals(this.reversal, chargebackDetails.reversal) &&
        Objects.equals(this.chargebackRefNum, chargebackDetails.chargebackRefNum) &&
        Objects.equals(this.documentStatus, chargebackDetails.documentStatus) &&
        Objects.equals(this.reconciliationAmount, chargebackDetails.reconciliationAmount) &&
        Objects.equals(this.reconciliationCurrency, chargebackDetails.reconciliationCurrency) &&
        Objects.equals(this.rejectReason, chargebackDetails.rejectReason) &&
        Objects.equals(this.editExclusionCode, chargebackDetails.editExclusionCode) &&
        Objects.equals(this.refundNotReceivedIndicator, chargebackDetails.refundNotReceivedIndicator) &&
        Objects.equals(this.creditVoucherStatus, chargebackDetails.creditVoucherStatus) &&
        Objects.equals(this.currencyConversionAssessmentCCAIncluded, chargebackDetails.currencyConversionAssessmentCCAIncluded) &&
        Objects.equals(this.currencyConversionAssessmentCCAAmount, chargebackDetails.currencyConversionAssessmentCCAAmount) &&
        Objects.equals(this.japanCommonMerchantCode, chargebackDetails.japanCommonMerchantCode) &&
        Objects.equals(this.installmentData, chargebackDetails.installmentData) &&
        Objects.equals(this.flexCode, chargebackDetails.flexCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(currency, createDate, documentIndicator, messageText, amount, reasonCode, isPartialChargeback, chargebackType, chargebackId, claimId, reversed, reversal, chargebackRefNum, documentStatus, reconciliationAmount, reconciliationCurrency, rejectReason, editExclusionCode, refundNotReceivedIndicator, creditVoucherStatus, currencyConversionAssessmentCCAIncluded, currencyConversionAssessmentCCAAmount, japanCommonMerchantCode, installmentData, flexCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChargebackDetails {\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    createDate: ").append(toIndentedString(createDate)).append("\n");
    sb.append("    documentIndicator: ").append(toIndentedString(documentIndicator)).append("\n");
    sb.append("    messageText: ").append(toIndentedString(messageText)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    reasonCode: ").append(toIndentedString(reasonCode)).append("\n");
    sb.append("    isPartialChargeback: ").append(toIndentedString(isPartialChargeback)).append("\n");
    sb.append("    chargebackType: ").append(toIndentedString(chargebackType)).append("\n");
    sb.append("    chargebackId: ").append(toIndentedString(chargebackId)).append("\n");
    sb.append("    claimId: ").append(toIndentedString(claimId)).append("\n");
    sb.append("    reversed: ").append(toIndentedString(reversed)).append("\n");
    sb.append("    reversal: ").append(toIndentedString(reversal)).append("\n");
    sb.append("    chargebackRefNum: ").append(toIndentedString(chargebackRefNum)).append("\n");
    sb.append("    documentStatus: ").append(toIndentedString(documentStatus)).append("\n");
    sb.append("    reconciliationAmount: ").append(toIndentedString(reconciliationAmount)).append("\n");
    sb.append("    reconciliationCurrency: ").append(toIndentedString(reconciliationCurrency)).append("\n");
    sb.append("    rejectReason: ").append(toIndentedString(rejectReason)).append("\n");
    sb.append("    editExclusionCode: ").append(toIndentedString(editExclusionCode)).append("\n");
    sb.append("    refundNotReceivedIndicator: ").append(toIndentedString(refundNotReceivedIndicator)).append("\n");
    sb.append("    creditVoucherStatus: ").append(toIndentedString(creditVoucherStatus)).append("\n");
    sb.append("    currencyConversionAssessmentCCAIncluded: ").append(toIndentedString(currencyConversionAssessmentCCAIncluded)).append("\n");
    sb.append("    currencyConversionAssessmentCCAAmount: ").append(toIndentedString(currencyConversionAssessmentCCAAmount)).append("\n");
    sb.append("    japanCommonMerchantCode: ").append(toIndentedString(japanCommonMerchantCode)).append("\n");
    sb.append("    installmentData: ").append(toIndentedString(installmentData)).append("\n");
    sb.append("    flexCode: ").append(toIndentedString(flexCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("currency");
    openapiFields.add("createDate");
    openapiFields.add("documentIndicator");
    openapiFields.add("messageText");
    openapiFields.add("amount");
    openapiFields.add("reasonCode");
    openapiFields.add("isPartialChargeback");
    openapiFields.add("chargebackType");
    openapiFields.add("chargebackId");
    openapiFields.add("claimId");
    openapiFields.add("reversed");
    openapiFields.add("reversal");
    openapiFields.add("chargebackRefNum");
    openapiFields.add("documentStatus");
    openapiFields.add("reconciliationAmount");
    openapiFields.add("reconciliationCurrency");
    openapiFields.add("rejectReason");
    openapiFields.add("editExclusionCode");
    openapiFields.add("refundNotReceivedIndicator");
    openapiFields.add("creditVoucherStatus");
    openapiFields.add("currencyConversionAssessmentCCAIncluded");
    openapiFields.add("currencyConversionAssessmentCCAAmount");
    openapiFields.add("japanCommonMerchantCode");
    openapiFields.add("installmentData");
    openapiFields.add("flexCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ChargebackDetails
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ChargebackDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ChargebackDetails is not found in the empty JSON string", ChargebackDetails.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ChargebackDetails.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ChargebackDetails` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      if ((jsonObj.get("createDate") != null && !jsonObj.get("createDate").isJsonNull()) && !jsonObj.get("createDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createDate").toString()));
      }
      if ((jsonObj.get("documentIndicator") != null && !jsonObj.get("documentIndicator").isJsonNull()) && !jsonObj.get("documentIndicator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentIndicator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentIndicator").toString()));
      }
      if ((jsonObj.get("messageText") != null && !jsonObj.get("messageText").isJsonNull()) && !jsonObj.get("messageText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `messageText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("messageText").toString()));
      }
      if ((jsonObj.get("amount") != null && !jsonObj.get("amount").isJsonNull()) && !jsonObj.get("amount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `amount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("amount").toString()));
      }
      if ((jsonObj.get("reasonCode") != null && !jsonObj.get("reasonCode").isJsonNull()) && !jsonObj.get("reasonCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reasonCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reasonCode").toString()));
      }
      if ((jsonObj.get("chargebackType") != null && !jsonObj.get("chargebackType").isJsonNull()) && !jsonObj.get("chargebackType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chargebackType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chargebackType").toString()));
      }
      if ((jsonObj.get("chargebackId") != null && !jsonObj.get("chargebackId").isJsonNull()) && !jsonObj.get("chargebackId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chargebackId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chargebackId").toString()));
      }
      if ((jsonObj.get("claimId") != null && !jsonObj.get("claimId").isJsonNull()) && !jsonObj.get("claimId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `claimId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("claimId").toString()));
      }
      if ((jsonObj.get("chargebackRefNum") != null && !jsonObj.get("chargebackRefNum").isJsonNull()) && !jsonObj.get("chargebackRefNum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chargebackRefNum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chargebackRefNum").toString()));
      }
      if ((jsonObj.get("documentStatus") != null && !jsonObj.get("documentStatus").isJsonNull()) && !jsonObj.get("documentStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentStatus").toString()));
      }
      if ((jsonObj.get("reconciliationAmount") != null && !jsonObj.get("reconciliationAmount").isJsonNull()) && !jsonObj.get("reconciliationAmount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reconciliationAmount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reconciliationAmount").toString()));
      }
      if ((jsonObj.get("reconciliationCurrency") != null && !jsonObj.get("reconciliationCurrency").isJsonNull()) && !jsonObj.get("reconciliationCurrency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reconciliationCurrency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reconciliationCurrency").toString()));
      }
      if ((jsonObj.get("rejectReason") != null && !jsonObj.get("rejectReason").isJsonNull()) && !jsonObj.get("rejectReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rejectReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rejectReason").toString()));
      }
      if ((jsonObj.get("editExclusionCode") != null && !jsonObj.get("editExclusionCode").isJsonNull()) && !jsonObj.get("editExclusionCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `editExclusionCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("editExclusionCode").toString()));
      }
      if ((jsonObj.get("refundNotReceivedIndicator") != null && !jsonObj.get("refundNotReceivedIndicator").isJsonNull()) && !jsonObj.get("refundNotReceivedIndicator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `refundNotReceivedIndicator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("refundNotReceivedIndicator").toString()));
      }
      if ((jsonObj.get("creditVoucherStatus") != null && !jsonObj.get("creditVoucherStatus").isJsonNull()) && !jsonObj.get("creditVoucherStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creditVoucherStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creditVoucherStatus").toString()));
      }
      if ((jsonObj.get("currencyConversionAssessmentCCAIncluded") != null && !jsonObj.get("currencyConversionAssessmentCCAIncluded").isJsonNull()) && !jsonObj.get("currencyConversionAssessmentCCAIncluded").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currencyConversionAssessmentCCAIncluded` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currencyConversionAssessmentCCAIncluded").toString()));
      }
      if ((jsonObj.get("currencyConversionAssessmentCCAAmount") != null && !jsonObj.get("currencyConversionAssessmentCCAAmount").isJsonNull()) && !jsonObj.get("currencyConversionAssessmentCCAAmount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currencyConversionAssessmentCCAAmount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currencyConversionAssessmentCCAAmount").toString()));
      }
      if ((jsonObj.get("japanCommonMerchantCode") != null && !jsonObj.get("japanCommonMerchantCode").isJsonNull()) && !jsonObj.get("japanCommonMerchantCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `japanCommonMerchantCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("japanCommonMerchantCode").toString()));
      }
      if ((jsonObj.get("installmentData") != null && !jsonObj.get("installmentData").isJsonNull()) && !jsonObj.get("installmentData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `installmentData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("installmentData").toString()));
      }
      if ((jsonObj.get("flexCode") != null && !jsonObj.get("flexCode").isJsonNull()) && !jsonObj.get("flexCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flexCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flexCode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ChargebackDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ChargebackDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ChargebackDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ChargebackDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<ChargebackDetails>() {
           @Override
           public void write(JsonWriter out, ChargebackDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ChargebackDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ChargebackDetails given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ChargebackDetails
  * @throws IOException if the JSON string is invalid with respect to ChargebackDetails
  */
  public static ChargebackDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ChargebackDetails.class);
  }

 /**
  * Convert an instance of ChargebackDetails to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

